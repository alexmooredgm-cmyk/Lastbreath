<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>LAST BREATH</title>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-app-pub-7375761383788184~9230735449" crossorigin="anonymous"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Special+Elite&display=swap');

  :root {
    --blood: #8b0000;
    --blood-bright: #cc0000;
    --flesh: #1a0a0a;
    --fog: rgba(10,0,0,0.85);
    --gold: #c9a84c;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; }

  body {
    background: #000;
    font-family: 'Special Elite', cursive;
    color: #ddd;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  #game-container {
    position: relative;
    width: 100%;
    height: 100%;
    max-width: 640px;
    max-height: 640px;
    overflow: hidden;
    border: 2px solid #330000;
    box-shadow: 0 0 60px rgba(139,0,0,0.4), inset 0 0 40px rgba(0,0,0,0.9);
  }

  canvas { display: block; width: 100%; height: 100%; }

  /* â”€â”€ HUD â”€â”€ */
  #hud {
    position: absolute; top: 0; left: 0; right: 0;
    display: flex; justify-content: space-between; align-items: center;
    padding: 8px 16px;
    background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
    pointer-events: none; z-index: 10;
  }
  #hud .stat { font-size: 13px; color: #aaa; letter-spacing: 1px; }
  #hud .stat span { color: var(--gold); font-size: 16px; }
  #level-badge {
    font-family: 'Creepster', cursive;
    font-size: 20px; color: var(--blood-bright);
    text-shadow: 0 0 10px var(--blood);
  }

  /* â”€â”€ HEARTBEAT bar â”€â”€ */
  #heartbar-wrap {
    position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
    display: flex; align-items: center; gap: 8px; z-index: 10; pointer-events: none;
  }
  #heartbar { width: 140px; height: 6px; background: #1a0000; border-radius: 3px; overflow: hidden; }
  #heartbar-fill { height: 100%; width: 0%; background: var(--blood-bright); transition: width 0.3s, background 0.3s; border-radius: 3px; }
  #heart-icon { font-size: 18px; animation: none; }
  @keyframes heartpulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.4)} }

  /* â”€â”€ VIGNETTE / flicker â”€â”€ */
  #vignette {
    position: absolute; inset: 0; pointer-events: none; z-index: 5;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.85) 100%);
    animation: flicker 4s infinite;
  }
  @keyframes flicker {
    0%,100%{opacity:1} 92%{opacity:1} 93%{opacity:0.7} 94%{opacity:1} 97%{opacity:0.85} 98%{opacity:1}
  }

  /* â”€â”€ OVERLAYS â”€â”€ */
  .overlay {
    position: absolute; inset: 0; display: flex; flex-direction: column;
    align-items: center; justify-content: center; z-index: 20;
    background: rgba(0,0,0,0.92);
    animation: fadeIn 0.4s ease;
    padding: 20px;
  }
  @keyframes fadeIn { from{opacity:0} to{opacity:1} }

  .overlay.blood-overlay { background: radial-gradient(ellipse, rgba(80,0,0,0.95) 0%, rgba(0,0,0,0.97) 100%); }

  .overlay h1 {
    font-family: 'Creepster', cursive;
    font-size: 48px; color: var(--blood-bright);
    text-shadow: 0 0 30px var(--blood), 0 0 60px rgba(139,0,0,0.5);
    letter-spacing: 4px; margin-bottom: 8px;
    text-align: center;
  }
  .overlay h2 {
    font-family: 'Creepster', cursive;
    font-size: 32px; color: #cc3333;
    text-shadow: 0 0 15px var(--blood); margin-bottom: 20px;
  }
  .overlay p { font-size: 14px; color: #888; margin-bottom: 6px; max-width: 380px; text-align: center; line-height: 1.6; }
  .overlay .score-display { font-size: 18px; color: var(--gold); margin: 12px 0; }

  .btn {
    margin-top: 16px; padding: 12px 32px;
    font-family: 'Special Elite', cursive; font-size: 16px; letter-spacing: 2px;
    border: none; cursor: pointer; border-radius: 2px;
    transition: all 0.2s; text-transform: uppercase;
    min-width: 200px;
  }
  .btn-red {
    background: var(--blood); color: #fff;
    box-shadow: 0 0 20px rgba(139,0,0,0.6);
  }
  .btn-red:hover, .btn-red:active { background: var(--blood-bright); box-shadow: 0 0 30px rgba(200,0,0,0.8); transform: scale(1.03); }
  .btn-ad {
    background: #1a1a00; color: var(--gold); border: 1px solid var(--gold);
    box-shadow: 0 0 15px rgba(201,168,76,0.3);
  }
  .btn-ad:hover, .btn-ad:active { background: #2a2a00; box-shadow: 0 0 25px rgba(201,168,76,0.5); transform: scale(1.03); }
  .btn-ad:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

  #controls-hint {
    position: absolute; bottom: 28px; right: 12px;
    font-size: 11px; color: #444; pointer-events: none; z-index: 10;
    line-height: 1.7;
  }

  /* Ad watching simulation */
  #ad-progress-wrap { width: 260px; margin-top: 10px; display: none; }
  #ad-bar { height: 8px; background: #111; border-radius: 4px; overflow: hidden; }
  #ad-fill { height: 100%; width: 0%; background: var(--gold); transition: width 0.1s linear; }
  #ad-label { font-size: 12px; color: #777; text-align: center; margin-top: 4px; }

  /* blood splatter */
  .splat {
    position: absolute; border-radius: 50%; background: var(--blood);
    animation: splatAnim 0.5s ease-out forwards; pointer-events: none; z-index: 15;
  }
  @keyframes splatAnim {
    0%{transform:scale(0);opacity:1} 60%{opacity:0.8} 100%{transform:scale(1);opacity:0}
  }

  /* level-up flash */
  #level-flash {
    position: absolute; inset: 0; background: rgba(139,0,0,0.3);
    z-index: 18; pointer-events: none; display: none;
    animation: none;
  }
  @keyframes flashAnim { 0%,100%{opacity:0} 50%{opacity:1} }
  
  /* AdMob ad container */
  #admob-ad-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 30;
    display: none;
    background: rgba(0,0,0,0.95);
    padding: 20px;
    border: 2px solid var(--gold);
    box-shadow: 0 0 30px rgba(201,168,76,0.5);
  }

  /* â”€â”€ JOYSTICK â”€â”€ */
  #joystick-zone {
    position: absolute;
    bottom: 20px;
    left: 20px;
    width: 120px;
    height: 120px;
    z-index: 15;
    display: none;
  }
  
  #joystick-base {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: rgba(139, 0, 0, 0.2);
    border: 2px solid rgba(139, 0, 0, 0.5);
  }
  
  #joystick-knob {
    position: absolute;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(200,0,0,0.8) 0%, rgba(139,0,0,0.9) 100%);
    border: 2px solid rgba(255,100,100,0.5);
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    box-shadow: 0 0 20px rgba(200,0,0,0.6);
    transition: transform 0.1s;
  }
  
  #joystick-knob.active {
    background: radial-gradient(circle, rgba(255,50,50,0.9) 0%, rgba(200,0,0,1) 100%);
    box-shadow: 0 0 30px rgba(255,0,0,0.8);
  }

  /* Touch controls hint */
  #touch-hint {
    position: absolute;
    bottom: 150px;
    left: 20px;
    font-size: 10px;
    color: #666;
    z-index: 10;
    pointer-events: none;
    display: none;
  }

  /* Mobile responsive adjustments */
  @media (max-width: 640px) {
    #game-container {
      border: none;
      max-width: 100%;
      max-height: 100%;
    }
    
    #joystick-zone {
      display: block;
    }
    
    #touch-hint {
      display: block;
    }
    
    #controls-hint {
      display: none;
    }
    
    .overlay h1 {
      font-size: 36px;
    }
    
    .btn {
      padding: 16px 40px;
      font-size: 18px;
    }
  }
</style>
</head>
<body>

<div id="game-container">
  <canvas id="canvas" width="640" height="640"></canvas>

  <!-- HUD -->
  <div id="hud">
    <div class="stat">SCORE <span id="score-display">0</span></div>
    <div id="level-badge">LEVEL <span id="level-display">1</span></div>
    <div class="stat">BEST <span id="best-display">0</span></div>
  </div>

  <!-- heartbeat -->
  <div id="heartbar-wrap">
    <span id="heart-icon">ğŸ–¤</span>
    <div id="heartbar"><div id="heartbar-fill"></div></div>
  </div>

  <div id="controls-hint">WASD / Arrow Keys</div>
  <div id="touch-hint">DRAG TO MOVE</div>
  <div id="vignette"></div>
  <div id="level-flash"></div>

  <!-- Joystick -->
  <div id="joystick-zone">
    <div id="joystick-base"></div>
    <div id="joystick-knob"></div>
  </div>

  <!-- START SCREEN -->
  <div class="overlay" id="start-screen">
    <h1>LAST BREATH</h1>
    <p>You are trapped. It is hunting you.<br>Collect the key ğŸ— and reach the exit ğŸšª before it finds you.</p>
    <p style="margin-top:8px; color:#555;">Each level, it grows faster. You will not escape forever.</p>
    <p style="margin-top:12px; color:#666; font-size:12px;">Desktop: WASD / Arrows<br>Mobile: Touch joystick</p>
    <button class="btn btn-red" onclick="startGame()">ENTER THE DARK</button>
  </div>

  <!-- DEATH SCREEN -->
  <div class="overlay blood-overlay" id="death-screen" style="display:none">
    <h2>YOU DIED</h2>
    <div class="score-display">Score: <span id="death-score">0</span></div>
    <div id="ad-progress-wrap">
      <div id="ad-bar"><div id="ad-fill"></div></div>
      <div id="ad-label">Loading ad...</div>
    </div>
    <button class="btn btn-ad" id="revive-btn" onclick="watchAd()">ğŸ“º Watch Ad to Revive</button>
    <button class="btn btn-red" style="margin-top:8px" onclick="restartGame()">RESTART</button>
    <p style="margin-top:16px; font-size:12px; color:#444;">High Score: <span id="hs-display" style="color:#c9a84c">0</span></p>
  </div>

  <!-- WIN SCREEN -->
  <div class="overlay" id="win-screen" style="display:none">
    <h2 style="color:#c9a84c; text-shadow:0 0 20px gold">ESCAPED!</h2>
    <div class="score-display">Score: <span id="win-score">0</span></div>
    <p>It will be closer next time...</p>
    <button class="btn btn-red" onclick="nextLevel()">DESCEND DEEPER</button>
  </div>
  
  <!-- AdMob Ad Container -->
  <div id="admob-ad-container">
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-app-pub-7375761383788184~9230735449"
         data-ad-slot="2912739104"
         data-ad-format="auto"
         data-full-width-responsive="true"></ins>
    <button class="btn btn-red" onclick="closeAdAndRevive()" style="margin-top:10px; display:none;" id="close-ad-btn">Continue</button>
  </div>
</div>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AUDIO ENGINE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let actx = null;

function getACtx() {
  if (!actx) actx = new AudioCtx();
  return actx;
}

function playTone(freq, type, dur, vol=0.15, startTime=0) {
  try {
    const ctx = getACtx();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.connect(g); g.connect(ctx.destination);
    o.type = type; o.frequency.value = freq;
    g.gain.setValueAtTime(vol, ctx.currentTime + startTime);
    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + startTime + dur);
    o.start(ctx.currentTime + startTime);
    o.stop(ctx.currentTime + startTime + dur);
  } catch(e){}
}

function playHeartbeat(rate) {
  const delay = 0.05 + (1 - rate) * 0.7;
  playTone(60, 'sine', 0.08, 0.25);
  setTimeout(() => playTone(55, 'sine', 0.07, 0.2), 120);
  setTimeout(() => {
    if (gameRunning) playHeartbeat(proximityRatio);
  }, delay * 1000);
}
let heartbeatRunning = false;

function playStep() { playTone(80 + Math.random()*20, 'triangle', 0.05, 0.08); }
function playKeyPickup() {
  [400,600,800].forEach((f,i) => playTone(f, 'sine', 0.15, 0.2, i*0.08));
}
function playScream() {
  [300,150,80].forEach((f,i) => playTone(f, 'sawtooth', 0.4, 0.3, i*0.1));
}
function playSuccess() {
  [523,659,784,1047].forEach((f,i) => playTone(f, 'sine', 0.2, 0.2, i*0.12));
}
function playMonsterGrowl() {
  playTone(40 + Math.random()*20, 'sawtooth', 0.3, 0.15);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GAME STATE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const TILE = 40;
const COLS = 16, ROWS = 16;
const W = COLS * TILE, H = ROWS * TILE;

let gameRunning = false;
let level = 1, score = 0, bestScore = 0;
let hasKey = false;
let proximityRatio = 0;
let revivesLeft = 1;
let stepCount = 0;

let player = {x:1, y:1};
let monster = {x:14, y:14, fx:14*TILE, fy:14*TILE};
let keyPos = {x:0,y:0};
let exitPos = {x:0,y:0};
let maze = [];

// Input
const keys = {};
let joystickInput = { x: 0, y: 0, active: false };

// Keyboard input
document.addEventListener('keydown', e => {
  const m = {ArrowUp:'up',ArrowDown:'down',ArrowLeft:'left',ArrowRight:'right',
             w:'up',s:'down',a:'left',d:'right',
             W:'up',S:'down',A:'left',D:'right'};
  if (m[e.key]) { keys[m[e.key]] = true; e.preventDefault(); }
});
document.addEventListener('keyup', e => {
  const m = {ArrowUp:'up',ArrowDown:'down',ArrowLeft:'left',ArrowRight:'right',
             w:'up',s:'down',a:'left',d:'right',
             W:'up',S:'down',A:'left',D:'right'};
  if (m[e.key]) keys[m[e.key]] = false;
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// JOYSTICK CONTROLS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const joystickZone = document.getElementById('joystick-zone');
const joystickKnob = document.getElementById('joystick-knob');
const joystickBase = document.getElementById('joystick-base');

let joystickCenter = { x: 0, y: 0 };
let joystickTouchId = null;
const JOYSTICK_MAX_RADIUS = 35;

function initJoystick() {
  const rect = joystickZone.getBoundingClientRect();
  joystickCenter = {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2
  };
}

function updateJoystick(touchX, touchY) {
  const dx = touchX - joystickCenter.x;
  const dy = touchY - joystickCenter.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const angle = Math.atan2(dy, dx);
  
  const clampedDistance = Math.min(distance, JOYSTICK_MAX_RADIUS);
  const knobX = Math.cos(angle) * clampedDistance;
  const knobY = Math.sin(angle) * clampedDistance;
  
  joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
  
  // Normalize input (-1 to 1)
  joystickInput.x = knobX / JOYSTICK_MAX_RADIUS;
  joystickInput.y = knobY / JOYSTICK_MAX_RADIUS;
  joystickInput.active = true;
  
  // Update keys based on joystick direction
  const deadzone = 0.3;
  keys.up = joystickInput.y < -deadzone;
  keys.down = joystickInput.y > deadzone;
  keys.left = joystickInput.x < -deadzone;
  keys.right = joystickInput.x > deadzone;
}

function resetJoystick() {
  joystickKnob.style.transform = 'translate(-50%, -50%)';
  joystickInput = { x: 0, y: 0, active: false };
  keys.up = keys.down = keys.left = keys.right = false;
  joystickKnob.classList.remove('active');
}

joystickZone.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (joystickTouchId === null) {
    const touch = e.changedTouches[0];
    joystickTouchId = touch.identifier;
    joystickKnob.classList.add('active');
    initJoystick();
    updateJoystick(touch.clientX, touch.clientY);
  }
}, { passive: false });

joystickZone.addEventListener('touchmove', (e) => {
  e.preventDefault();
  for (let i = 0; i < e.changedTouches.length; i++) {
    if (e.changedTouches[i].identifier === joystickTouchId) {
      updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
      break;
    }
  }
}, { passive: false });

joystickZone.addEventListener('touchend', (e) => {
  e.preventDefault();
  for (let i = 0; i < e.changedTouches.length; i++) {
    if (e.changedTouches[i].identifier === joystickTouchId) {
      joystickTouchId = null;
      resetJoystick();
      break;
    }
  }
});

joystickZone.addEventListener('touchcancel', (e) => {
  joystickTouchId = null;
  resetJoystick();
});

// Mouse fallback for desktop testing
let mouseDown = false;
joystickZone.addEventListener('mousedown', (e) => {
  e.preventDefault();
  mouseDown = true;
  joystickKnob.classList.add('active');
  initJoystick();
  updateJoystick(e.clientX, e.clientY);
});

document.addEventListener('mousemove', (e) => {
  if (mouseDown) {
    updateJoystick(e.clientX, e.clientY);
  }
});

document.addEventListener('mouseup', () => {
  if (mouseDown) {
    mouseDown = false;
    resetJoystick();
  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MAZE GENERATION (Recursive backtracker)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateMaze() {
  maze = Array.from({length:ROWS}, () => Array(COLS).fill(1));
  const visited = Array.from({length:ROWS}, () => Array(COLS).fill(false));
  
  function carve(r, c) {
    visited[r][c] = true;
    maze[r][c] = 0;
    const dirs = [{dr:-2,dc:0},{dr:2,dc:0},{dr:0,dc:-2},{dr:0,dc:2}]
      .sort(() => Math.random()-0.5);
    for (const {dr, dc} of dirs) {
      const nr = r+dr, nc = c+dc;
      if (nr>0 && nr<ROWS-1 && nc>0 && nc<COLS-1 && !visited[nr][nc]) {
        maze[r+dr/2][c+dc/2] = 0;
        carve(nr, nc);
      }
    }
  }
  carve(1, 1);

  for (let r=0;r<ROWS;r++) { maze[r][0]=1; maze[r][COLS-1]=1; }
  for (let c=0;c<COLS;c++) { maze[0][c]=1; maze[ROWS-1][c]=1; }

  const opens = [];
  for (let r=1;r<ROWS-1;r++) for (let c=1;c<COLS-1;c++)
    if (maze[r][c]===0) opens.push({x:c,y:r});
  
  const farOpens = opens.filter(p => Math.abs(p.x-1)+Math.abs(p.y-1) > 8);
  keyPos = farOpens[Math.floor(Math.random()*farOpens.length)] || opens[opens.length-1];
  exitPos = {x: COLS-2, y: ROWS-2};
  maze[exitPos.y][exitPos.x] = 0;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PATHFINDING (BFS for monster)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function bfsPath(sx, sy, tx, ty) {
  const visited = Array.from({length:ROWS}, () => Array(COLS).fill(false));
  const prev = Array.from({length:ROWS}, () => Array(COLS).fill(null));
  const q = [{x:sx,y:sy}];
  visited[sy][sx] = true;
  const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
  while (q.length) {
    const {x,y} = q.shift();
    if (x===tx && y===ty) {
      const path = [];
      let cur = {x,y};
      while (prev[cur.y][cur.x]) { path.unshift(cur); cur = prev[cur.y][cur.x]; }
      return path;
    }
    for (const {dx,dy} of dirs) {
      const nx=x+dx, ny=y+dy;
      if (nx>=0&&nx<COLS&&ny>=0&&ny<ROWS&&!visited[ny][nx]&&maze[ny][nx]===0) {
        visited[ny][nx]=true; prev[ny][nx]={x,y}; q.push({x:nx,y:ny});
      }
    }
  }
  return [];
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GAME LOGIC
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let lastTime = 0;
let moveTimer = 0;
let monsterTimer = 0;
let playerMoveDelay = 150;
let monsterMoveDelay;

function getMonsterSpeed() { return Math.max(160 - level * 15, 50); }

function startGame() {
  level = 1; score = 0; revivesLeft = 1;
  document.getElementById('start-screen').style.display = 'none';
  initLevel();
}

function initLevel() {
  generateMaze();
  player = {x:1, y:1};
  monster = {x:COLS-2, y:ROWS-2, fx:(COLS-2)*TILE, fy:(ROWS-2)*TILE};
  hasKey = false;
  monsterMoveDelay = getMonsterSpeed();
  moveTimer = 0; monsterTimer = 0;
  gameRunning = true;
  updateHUD();
  if (!heartbeatRunning) { heartbeatRunning=true; playHeartbeat(0); }
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

function updateHUD() {
  document.getElementById('score-display').textContent = score;
  document.getElementById('level-display').textContent = level;
  document.getElementById('best-display').textContent = bestScore;
}

function update(dt) {
  moveTimer += dt;
  monsterTimer += dt;

  if (moveTimer >= playerMoveDelay) {
    let dx=0, dy=0;
    if (keys.up) dy=-1;
    else if (keys.down) dy=1;
    else if (keys.left) dx=-1;
    else if (keys.right) dx=1;

    if (dx!==0||dy!==0) {
      const nx=player.x+dx, ny=player.y+dy;
      if (nx>=0&&nx<COLS&&ny>=0&&ny<ROWS&&maze[ny][nx]===0) {
        player.x=nx; player.y=ny;
        moveTimer=0;
        stepCount++;
        if (stepCount%2===0) playStep();

        if (!hasKey && player.x===keyPos.x && player.y===keyPos.y) {
          hasKey=true; score+=50; playKeyPickup();
        }
        if (hasKey && player.x===exitPos.x && player.y===exitPos.y) {
          winLevel();
        }
      }
    }
  }

  if (monsterTimer >= monsterMoveDelay) {
    monsterTimer=0;
    const path = bfsPath(monster.x, monster.y, player.x, player.y);
    if (path.length>0) {
      monster.x = path[0].x;
      monster.y = path[0].y;
      if (Math.random()<0.1) playMonsterGrowl();
    }
  }

  monster.fx += (monster.x*TILE - monster.fx) * 0.18;
  monster.fy += (monster.y*TILE - monster.fy) * 0.18;

  const dist = Math.abs(player.x-monster.x)+Math.abs(player.y-monster.y);
  proximityRatio = Math.max(0, 1 - dist/10);
  const fill = document.getElementById('heartbar-fill');
  fill.style.width = (proximityRatio*100)+'%';
  fill.style.background = proximityRatio > 0.6 ? '#ff0000' : '#8b0000';
  document.getElementById('heart-icon').style.animation =
    proximityRatio > 0.3 ? `heartpulse ${0.4+0.6*(1-proximityRatio)}s infinite` : 'none';
  document.getElementById('heart-icon').textContent = proximityRatio > 0.6 ? 'â¤ï¸' : 'ğŸ–¤';

  if (monster.x===player.x && monster.y===player.y) {
    playerDied();
  }

  if (Math.random() < 0.01) { score++; updateHUD(); }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RENDERING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let camX=0, camY=0;

function render() {
  const targetCX = player.x*TILE - W/2 + TILE/2;
  const targetCY = player.y*TILE - H/2 + TILE/2;
  camX += (targetCX - camX) * 0.12;
  camY += (targetCY - camY) * 0.12;
  camX = Math.max(0, Math.min(COLS*TILE-W, camX));
  camY = Math.max(0, Math.min(ROWS*TILE-H, camY));

  ctx.save();
  ctx.translate(-camX, -camY);

  ctx.fillStyle = '#0a0000';
  ctx.fillRect(camX, camY, W, H);

  const gradient = ctx.createRadialGradient(
    player.x*TILE+TILE/2, player.y*TILE+TILE/2, TILE*0.5,
    player.x*TILE+TILE/2, player.y*TILE+TILE/2, TILE*(3.5 + proximityRatio*-1.5)
  );
  gradient.addColorStop(0, 'rgba(0,0,0,0)');
  gradient.addColorStop(1, 'rgba(0,0,0,1)');

  for (let r=0;r<ROWS;r++) {
    for (let c=0;c<COLS;c++) {
      const tx=c*TILE, ty=r*TILE;
      if (tx+TILE<camX||tx>camX+W||ty+TILE<camY||ty>camY+H) continue;
      if (maze[r][c]===1) {
        ctx.fillStyle = '#0f0000';
        ctx.fillRect(tx,ty,TILE,TILE);
        ctx.fillStyle = '#1a0505';
        ctx.fillRect(tx+1,ty+1,TILE-2,TILE-2);
        ctx.strokeStyle='#0a0000';
        ctx.lineWidth=0.5;
        ctx.strokeRect(tx+1,ty+1,TILE-2,TILE-2);
      } else {
        ctx.fillStyle = '#110000';
        ctx.fillRect(tx,ty,TILE,TILE);
        if ((r+c)%2===0) {
          ctx.fillStyle='rgba(255,255,255,0.01)';
          ctx.fillRect(tx,ty,TILE,TILE);
        }
      }
    }
  }

  if (!hasKey) {
    const kx=keyPos.x*TILE, ky=keyPos.y*TILE;
    const glow = ctx.createRadialGradient(kx+TILE/2,ky+TILE/2,0,kx+TILE/2,ky+TILE/2,TILE);
    glow.addColorStop(0,'rgba(201,168,76,0.3)'); glow.addColorStop(1,'transparent');
    ctx.fillStyle=glow; ctx.fillRect(kx-TILE,ky-TILE,TILE*3,TILE*3);
    ctx.font='22px serif'; ctx.textAlign='center';
    ctx.fillText('ğŸ—', kx+TILE/2, ky+TILE/2+8);
  }

  const ex=exitPos.x*TILE, ey=exitPos.y*TILE;
  if (hasKey) {
    const glow2 = ctx.createRadialGradient(ex+TILE/2,ey+TILE/2,0,ex+TILE/2,ey+TILE/2,TILE*1.5);
    glow2.addColorStop(0,'rgba(0,200,0,0.2)'); glow2.addColorStop(1,'transparent');
    ctx.fillStyle=glow2; ctx.fillRect(ex-TILE,ey-TILE,TILE*3,TILE*3);
  }
  ctx.font='22px serif'; ctx.textAlign='center';
  ctx.fillText('ğŸšª', ex+TILE/2, ey+TILE/2+8);

  const pg = ctx.createRadialGradient(player.x*TILE+TILE/2, player.y*TILE+TILE/2, 0,
                                       player.x*TILE+TILE/2, player.y*TILE+TILE/2, TILE*2.5);
  pg.addColorStop(0,'rgba(255,200,100,0.15)'); pg.addColorStop(1,'transparent');
  ctx.fillStyle=pg; ctx.fillRect(player.x*TILE-TILE*2, player.y*TILE-TILE*2, TILE*6, TILE*6);

  ctx.font='24px serif'; ctx.textAlign='center';
  ctx.fillText('ğŸ§', player.x*TILE+TILE/2, player.y*TILE+TILE/2+8);

  const mg = ctx.createRadialGradient(monster.fx+TILE/2, monster.fy+TILE/2, 0,
                                       monster.fx+TILE/2, monster.fy+TILE/2, TILE*2);
  mg.addColorStop(0,'rgba(180,0,0,0.35)'); mg.addColorStop(1,'transparent');
  ctx.fillStyle=mg; ctx.fillRect(monster.fx-TILE, monster.fy-TILE, TILE*4, TILE*4);

  ctx.font='26px serif'; ctx.textAlign='center';
  const shake = proximityRatio > 0.5 ? (Math.random()-0.5)*3 : 0;
  ctx.fillText('ğŸ‘', monster.fx+TILE/2+shake, monster.fy+TILE/2+8+shake);

  ctx.fillStyle=gradient; ctx.fillRect(camX,camY,W,H);

  ctx.restore();

  ctx.font='16px Special Elite';
  ctx.fillStyle = hasKey ? '#c9a84c' : '#444';
  ctx.textAlign='left';
  ctx.fillText(hasKey ? 'ğŸ— KEY FOUND â€“ FIND THE EXIT!' : 'ğŸ— Find the key...', 12, H-12);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LOOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop(ts) {
  if (!gameRunning) return;
  const dt = ts - lastTime; lastTime = ts;
  if (dt < 200) {
    update(dt);
  }
  render();
  requestAnimationFrame(loop);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EVENTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function playerDied() {
  gameRunning = false; heartbeatRunning = false;
  playScream();
  spawnSplatters();
  if (score > bestScore) bestScore = score;
  setTimeout(() => {
    document.getElementById('death-score').textContent = score;
    document.getElementById('hs-display').textContent = bestScore;
    const revBtn = document.getElementById('revive-btn');
    revBtn.disabled = revivesLeft <= 0;
    revBtn.textContent = revivesLeft > 0 ? 'ğŸ“º Watch Ad to Revive' : 'No Revives Left';
    document.getElementById('death-screen').style.display = 'flex';
  }, 600);
}

function winLevel() {
  gameRunning = false; heartbeatRunning = false;
  playSuccess();
  score += 100 * level;
  if (score > bestScore) bestScore = score;
  document.getElementById('win-score').textContent = score;
  document.getElementById('win-screen').style.display = 'flex';
}

function nextLevel() {
  document.getElementById('win-screen').style.display='none';
  level++; revivesLeft=1;
  const f = document.getElementById('level-flash');
  f.style.display='block';
  f.style.animation='flashAnim 0.6s ease';
  setTimeout(()=>{f.style.display='none';f.style.animation='none';},600);
  initLevel();
}

function restartGame() {
  document.getElementById('death-screen').style.display='none';
  level=1; score=0; revivesLeft=1;
  initLevel();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ADMOB REWARDED AD INTEGRATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const AD_UNIT_ID = 'ca-app-pub-7375761383788184/2912739104';
let rewardedAd = null;
let adRewardEarned = false;
let adLoading = false;

// Initialize AdMob when API is ready
window.addEventListener('load', () => {
  if (typeof google !== 'undefined' && google.ima) {
    initAdMob();
  } else {
    // Fallback: AdMob not loaded, use simulation
    console.log('AdMob not available, using simulation mode');
  }
});

function initAdMob() {
  try {
    // Check for AdMob API
    if (typeof adsbygoogle !== 'undefined') {
      console.log('AdMob initialized');
      loadRewardedAd();
    }
  } catch (e) {
    console.error('AdMob init error:', e);
  }
}

function loadRewardedAd() {
  if (adLoading) return;
  adLoading = true;
  
  try {
    // Request rewarded ad
    (adsbygoogle = window.adsbygoogle || []).push({
      google_ad_client: "ca-app-pub-7375761383788184~9230735449",
      google_ad_slot: "2912739104",
      google_ad_format: "rewarded",
      google_full_width_responsive: true
    });
    
    // Set up event listeners
    setupAdMobListeners();
  } catch (e) {
    console.error('Ad load error:', e);
    adLoading = false;
  }
}

function setupAdMobListeners() {
  // Rewarded ad event handlers
  window.addEventListener('admob.rewarded.loaded', () => {
    console.log('Rewarded ad loaded');
    adLoading = false;
    rewardedAd = true;
  });
  
  window.addEventListener('admob.rewarded.opened', () => {
    console.log('Rewarded ad opened');
    gameRunning = false; // Pause game while ad is showing
  });
  
  window.addEventListener('admob.rewarded.closed', () => {
    console.log('Rewarded ad closed');
    if (adRewardEarned) {
      closeAdAndRevive();
    } else {
      // User closed ad without reward
      document.getElementById('ad-progress-wrap').style.display = 'none';
      document.getElementById('revive-btn').disabled = false;
      document.getElementById('revive-btn').textContent = 'ğŸ“º Watch Ad to Revive';
    }
    loadRewardedAd(); // Preload next ad
  });
  
  window.addEventListener('admob.rewarded.rewarded', (event) => {
    console.log('Reward earned:', event);
    adRewardEarned = true;
  });
  
  window.addEventListener('admob.rewarded.error', (error) => {
    console.error('Ad error:', error);
    adLoading = false;
    // Fallback to simulation
    simulateAd();
  });
}

function watchAd() {
  if (revivesLeft <= 0) return;
  
  const btn = document.getElementById('revive-btn');
  btn.disabled = true;
  
  // Show loading UI
  const wrap = document.getElementById('ad-progress-wrap');
  const fill = document.getElementById('ad-fill');
  const label = document.getElementById('ad-label');
  
  wrap.style.display = 'block';
  fill.style.width = '0%';
  label.textContent = 'Loading rewarded ad...';
  
  // Try to show real AdMob ad
  if (typeof adsbygoogle !== 'undefined' && rewardedAd) {
    try {
      // Trigger ad display
      (adsbygoogle = window.adsbygoogle || []).push({
        google_ad_client: "ca-app-pub-7375761383788184~9230735449",
        google_ad_slot: "2912739104"
      });
    } catch (e) {
      console.error('Ad show error:', e);
      simulateAd();
    }
  } else {
    // No ad loaded, use simulation
    simulateAd();
  }
}

function simulateAd() {
  // Simulated ad for testing/fallback
  const fill = document.getElementById('ad-fill');
  const label = document.getElementById('ad-label');
  
  label.textContent = 'Ad playing...';
  
  let progress = 0;
  const interval = setInterval(() => {
    progress += 2;
    fill.style.width = progress + '%';
    
    if (progress >= 100) {
      clearInterval(interval);
      label.textContent = 'âœ“ Reward earned!';
      adRewardEarned = true;
      setTimeout(() => {
        closeAdAndRevive();
      }, 500);
    }
  }, 60);
}

function closeAdAndRevive() {
  if (!adRewardEarned) return;
  
  // Hide all ad UI
  document.getElementById('admob-ad-container').style.display = 'none';
  document.getElementById('death-screen').style.display = 'none';
  document.getElementById('ad-progress-wrap').style.display = 'none';
  
  revivesLeft--;
  adRewardEarned = false;
  rewardedAd = null;
  
  // Revive player
  player = {x: 1, y: 1};
  monster = {x: COLS-2, y: ROWS-2, fx: (COLS-2)*TILE, fy: (ROWS-2)*TILE};
  gameRunning = true;
  heartbeatRunning = true;
  lastTime = performance.now();
  playHeartbeat(0);
  requestAnimationFrame(loop);
  
  // Preload next ad
  setTimeout(loadRewardedAd, 1000);
}

function spawnSplatters() {
  const container = document.getElementById('game-container');
  for (let i = 0; i < 18; i++) {
    const s = document.createElement('div');
    s.className = 'splat';
    const size = 10 + Math.random() * 50;
    s.style.width = size + 'px';
    s.style.height = size + 'px';
    s.style.left = (player.x * TILE - camX - size / 2 + Math.random() * 80 - 40) + 'px';
    s.style.top = (player.y * TILE - camY - size / 2 + Math.random() * 80 - 40) + 'px';
    s.style.opacity = 0.8 + Math.random() * 0.2;
    s.style.animationDuration = (0.4 + Math.random() * 0.4) + 's';
    container.appendChild(s);
    setTimeout(() => s.remove(), 900);
  }
}

// Handle resize
window.addEventListener('resize', () => {
  initJoystick();
});
</script>
</body>
</html>

